// std_bhm/src/os/mkdir_p.cpp

// -----------------------------------------------------------------------

// The function mkdir_p(...) was taken from https://gist.github.com/
// JonathonReinhart/8c0d90191c38af2dcadb102c4e202950.

// -----------------------------------------------------------------------


/* Include standard libraries */
#include <cstddef>
#include <cstring>
#include <climits>
#include <cerrno>
#include <sys/stat.h>

/* Include user-defined header files */
#include "os/mkdir_p.h"


// Declaring 'private' helper functions that serve as implementation details.
namespace std_bhm
{
namespace os
{
namespace helper
{
namespace
{

int check_pathname_length(const char *path);
int make_parent_directories(char *path);
int make_lowest_subdirectory(const char *path);

} // end of anonymous namespace
} // end of helper namespace
} // end of os namespace
} // end of std_bhm namespace


namespace std_bhm
{
namespace os
{

// Create directory with pathname path and create any parent any directories
// if necessary.
int mkdir_p(const char *path)
{

    namespace NS1 = std_bhm::os;
    if (NS1::helper::check_pathname_length(path) == -1) { return -1; }
    char path_copy[PATH_MAX];
    strcpy(path_copy, path);
    if (NS1::helper::make_parent_directories(path_copy) == -1) { return -1; }
    if (NS1::helper::make_lowest_subdirectory(path_copy) == -1) { return -1; }
    return 0;

} // end of mkdir_p(...) definition

} // end of os namespace
} // end of std_bhm namespace


// Definitions of helper functions used in simulation_parameters class.

namespace std_bhm
{
namespace os
{
namespace helper
{
namespace
{

// Check to see if pathname length is does not go beyond the maximum allowable
// length (i.e. PATH_MAX).
int check_pathname_length(const char *path)
{

    const size_t len = std::strlen(path);
    char copy_of_original[PATH_MAX];
    if (len > sizeof(copy_of_original)-1) 
    {
        errno = ENAMETOOLONG;
        return -1; 
    }   

    return 0;

} // end of copy_char_array(...) definition

} // end of anonymous namespace
} // end of helper namespace
} // end of os namespace
} // end of std_bhm namespace


namespace std_bhm
{
namespace os
{
namespace helper
{
namespace
{

// Make parent directories for pathname 'path'.
int make_parent_directories(char *path)
{

    char *char_ptr;
    for(char_ptr=path+1; *char_ptr; char_ptr++) 
    {
        if (*char_ptr == '/') 
	{
            *char_ptr = '\0'; // Temporarily truncate path
	    /* S_IRWXU = Read, write, execute/search by owner */
            if (mkdir(path, S_IRWXU) != 0)
	    {
                if (errno != EEXIST) // EEXIST = File exists
                    return -1; 
            }

            *char_ptr = '/';
        }
    } // end of for-loop

    return 0;

} // end of make_parent_directories(...) definition

} // end of anonymous namespace
} // end of helper namespace
} // end of os namespace
} // end of std_bhm namespace


namespace std_bhm
{
namespace os
{
namespace helper
{
namespace
{

// Make lowest subdirectory specified in pathname 'path'.
int make_lowest_subdirectory(const char *path)
{
    /* S_IRWXU = Read, write, execute/search by owner */
    if (mkdir(path, S_IRWXU) != 0) 
    {
        if (errno != EEXIST) // EEXIST = File exists
            return -1; 
    }

    return 0;

} // end of make_lowest_subdirectory(...) definition

} // end of anonymous namespace
} // end of helper namespace
} // end of os namespace
} // end of std_bhm namespace
